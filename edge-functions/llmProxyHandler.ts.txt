// LLMProxyHandler: Unified proxy for multiple LLM providers (OpenAI, Anthropic, Gemini, LM Studio, Ollama)
// Supports: chat completions, embeddings, model listing
// Security: authentication, input validation, rate limiting

import { serve } from "https://deno.land/std@0.177.0/http/server.ts";
import { corsHeaders } from "./cors.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.7.1";

// Initialize Supabase client
const supabaseUrl = Deno.env.get("SUPABASE_URL");
const supabaseServiceKey = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY");
const supabase = createClient(supabaseUrl, supabaseServiceKey);

// Provider endpoints and API key environment variables
const PROVIDER_CONFIG = {
  openai: {
    endpoint: "https://api.openai.com/v1",
    key: Deno.env.get("OPENAI_API_KEY"),
  },
  anthropic: {
    endpoint: "https://api.anthropic.com/v1",
    key: Deno.env.get("ANTHROPIC_API_KEY"),
  },
  gemini: {
    endpoint: "https://generativelanguage.googleapis.com/v1",
    key: Deno.env.get("GEMINI_API_KEY"),
  },
  lmstudio: {
    endpoint: "http://localhost:1234/v1",
    key: null, // Local, no key
  },
  ollama: {
    endpoint: "http://localhost:11434/api",
    key: null, // Local, no key
  },
};

const RATE_LIMIT = 60; // requests per minute per user (example)
const rateLimitMap = new Map<string, { count: number; last: number }>();

function rateLimit(ip: string): boolean {
  const now = Date.now();
  const windowMs = 60 * 1000;
  const entry = rateLimitMap.get(ip) || { count: 0, last: now };
  if (now - entry.last > windowMs) {
    entry.count = 1;
    entry.last = now;
  } else {
    entry.count += 1;
  }
  rateLimitMap.set(ip, entry);
  return entry.count <= RATE_LIMIT;
}

function validateInput(provider: string, body: any): string | null {
  if (!provider || !(provider in PROVIDER_CONFIG)) return "Invalid provider";
  if (!body) return "Missing request body";
  // Basic validation for supported endpoints
  if (!["chat", "embeddings", "models"].includes(body.type)) return "Invalid type";
  if (body.type === "chat" && !body.messages) return "Missing messages for chat";
  if (body.type === "embeddings" && !body.input) return "Missing input for embeddings";
  return null;
}

async function proxyRequest(provider: string, type: string, body: any, headers: Headers) {
  const config = PROVIDER_CONFIG[provider];
  let url = config.endpoint;
  let method = "POST";
  let reqBody = {};
  let reqHeaders: Record<string, string> = {};

  switch (provider) {
    case "openai":
      if (type === "chat") {
        url += "/chat/completions";
        reqBody = {
          model: body.model,
          messages: body.messages,
          ...body.options,
        };
      } else if (type === "embeddings") {
        url += "/embeddings";
        reqBody = {
          model: body.model,
          input: body.input,
          ...body.options,
        };
      } else if (type === "models") {
        url += "/models";
        method = "GET";
      }
      reqHeaders = {
        "Authorization": `Bearer ${config.key}`,
        "Content-Type": "application/json",
        "OpenAI-Beta": "assistants=v1",  // For newer features
        "OpenAI-Organization": Deno.env.get("OPENAI_ORG_ID") || "", // Optional organization ID
      };
      break;
    case "anthropic":
      if (type === "chat") {
        url += "/messages";
        reqBody = {
          model: body.model,
          messages: body.messages,
          ...body.options,
        };
      } else if (type === "embeddings") {
        url += "/embeddings";
        reqBody = {
          model: body.model,
          input: body.input,
          ...body.options,
        };
      } else if (type === "models") {
        url += "/models";
        method = "GET";
      }
      reqHeaders = {
        "x-api-key": config.key,
        "Content-Type": "application/json",
        "anthropic-version": "2023-06-01"
      };
      break;
    case "gemini":
      if (type === "chat") {
        url += `/models/${body.model}:generateContent?key=${config.key}`;
        reqBody = {
          contents: body.messages.map(msg => ({
            role: msg.role,
            parts: [{ text: msg.content }]
          })),
          generationConfig: {
            temperature: body.options?.temperature || 0.7,
            ...body.options
          }
        };
      } else if (type === "embeddings") {
        url += `/models/${body.model}:embedContent?key=${config.key}`;
        reqBody = {
          content: { parts: [{ text: body.input }] },
          ...body.options,
        };
      } else if (type === "models") {
        url += `/models?key=${config.key}`;
        method = "GET";
      }
      reqHeaders = {
        "Content-Type": "application/json",
      };
      break;
    case "lmstudio":
      if (type === "chat") {
        url += "/chat/completions";
        reqBody = {
          model: body.model,
          messages: body.messages,
          ...body.options,
        };
      } else if (type === "embeddings") {
        url += "/embeddings";
        reqBody = {
          model: body.model,
          input: body.input,
          ...body.options,
        };
      } else if (type === "models") {
        url += "/models";
        method = "GET";
      }
      reqHeaders = {
        "Content-Type": "application/json",
      };
      break;
    case "ollama":
      if (type === "chat") {
        url += "/chat";
        reqBody = {
          model: body.model,
          messages: body.messages,
          ...body.options,
        };
      } else if (type === "embeddings") {
        url += "/embeddings";
        reqBody = {
          model: body.model,
          input: body.input,
          ...body.options,
        };
      } else if (type === "models") {
        url += "/tags";
        method = "GET";
      }
      reqHeaders = {
        "Content-Type": "application/json",
      };
      break;
    default:
      throw new Error("Unsupported provider");
  }

  const fetchOptions: RequestInit = {
    method,
    headers: reqHeaders,
  };
  if (method === "POST") fetchOptions.body = JSON.stringify(reqBody);

  const resp = await fetch(url, fetchOptions);
  const data = await resp.json();
  
  // Log detailed error information for debugging
  if (resp.status >= 400) {
    console.error(`API Error (${provider}): Status ${resp.status}`, data);
  }
  
  return { status: resp.status, data };
}

// Function to get API key from key_store table
async function getApiKeyFromDatabase(userId: string, provider: string): Promise<string | null> {
  try {
    const { data, error } = await supabase
      .from('key_store')
      .select('api_key')
      .eq('user_id', userId)
      .eq('provider', provider)
      .single();
    
    if (error) {
      console.error('Error fetching API key:', error);
      return null;
    }
    
    return data?.api_key || null;
  } catch (err) {
    console.error('Exception fetching API key:', err);
    return null;
  }
}

serve(async (req) => {
  // CORS preflight
  if (req.method === "OPTIONS") {
    return new Response("ok", { headers: corsHeaders });
  }

  // Basic authentication (e.g., via Authorization header or Supabase JWT)
  const authHeader = req.headers.get("Authorization");
  if (!authHeader || !authHeader.startsWith("Bearer ")) {
    return new Response(JSON.stringify({ error: "Unauthorized" }), {
      status: 401,
      headers: corsHeaders,
    });
  }
  
  // Extract JWT token and verify
  const authToken = authHeader.replace('Bearer ', '');
  
  // Verify JWT and get user ID
  let userId: string;
  try {
    // Decode JWT to get user ID
    const { data: userData, error } = await supabase.auth.getUser(authToken);
    if (error) throw error;
    userId = userData.user.id;
  } catch (err) {
    return new Response(JSON.stringify({ error: "Invalid authentication token" }), {
      status: 401,
      headers: corsHeaders,
    });
  }

  // Rate limiting by IP
  const ip = req.headers.get("x-forwarded-for") || "unknown";
  if (!rateLimit(ip)) {
    return new Response(JSON.stringify({ error: "Rate limit exceeded" }), {
      status: 429,
      headers: corsHeaders,
    });
  }

  let body: any;
  try {
    body = await req.json();
  } catch {
    return new Response(JSON.stringify({ error: "Invalid JSON" }), {
      status: 400,
      headers: corsHeaders,
    });
  }

  const { provider: rawProvider, ...rest } = body;
  // Normalize provider to lowercase for case-insensitive comparison
  const provider = rawProvider?.toLowerCase();
  const validationError = validateInput(provider, rest);
  if (validationError) {
    return new Response(JSON.stringify({ error: validationError }), {
      status: 400,
      headers: corsHeaders,
    });
  }

  try {
    // Try to get API key from database first
    const dbApiKey = await getApiKeyFromDatabase(userId, provider);
    
    // Log provider for debugging
    console.log(`Processing request for provider: ${provider} (original: ${rawProvider})`);
    
    // Use API key from database if available, otherwise fall back to environment variable
    if (dbApiKey) {
      PROVIDER_CONFIG[provider].key = dbApiKey;
    }
    // If no key in database or environment, check if provided in Authorization
    else if (!PROVIDER_CONFIG[provider].key) {
      PROVIDER_CONFIG[provider].key = authToken;
    }
    
    // If still no API key and provider requires one, return error
    if (!PROVIDER_CONFIG[provider].key && provider !== "lmstudio" && provider !== "ollama") {
      return new Response(JSON.stringify({ error: `No API key available for ${provider}` }), {
        status: 400,
        headers: corsHeaders,
      });
    }
    
    try {
      const { status, data } = await proxyRequest(provider, rest.type, rest, req.headers);
    
    // Format response to match what the frontend expects
    let formattedResponse = data;
    if (rest.type === "chat") {
      // Format based on provider
      if (provider === "openai") {
        formattedResponse = {
          content: data.choices?.[0]?.message?.content || "No response"
        };
      } else if (provider === "anthropic") {
        formattedResponse = {
          content: data.content?.[0]?.text || "No response"
        };
      } else if (provider === "gemini") {
        formattedResponse = {
          content: data.candidates?.[0]?.content?.parts?.[0]?.text || "No response"
        };
      } else if (provider === "lmstudio" || provider === "ollama") {
        formattedResponse = {
          content: data.choices?.[0]?.message?.content || data.message?.content || "No response"
        };
      }
    }
    
    // If there was an error from the provider API, include the error details in the response
    if (status >= 400) {
      console.error(`Provider API Error (${provider}):`, data);
      return new Response(JSON.stringify({
        error: data.error?.message || "Provider API error",
        details: data.error || data,
        provider: provider,
        model: rest.model
      }), {
        status,
        headers: corsHeaders,
      });
    }
    
    return new Response(JSON.stringify(formattedResponse), {
      status,
      headers: corsHeaders,
    });
  } catch (err) {
    console.error(`Edge function error:`, err);
    return new Response(JSON.stringify({
      error: err.message,
      stack: err.stack,
      provider: provider,
      model: rest?.model
    }), {
      status: 500,
      headers: corsHeaders,
    });
  }
});